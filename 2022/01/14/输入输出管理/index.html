<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/kou.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>地下室 输入输出管理 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 5.4.1"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <!-- <a class="menu__item" href="/">作品</a> -->
    <!-- <a class="menu__item" href="/about/">关于</a> -->
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">输入输出管理</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2022-01-14T01:43:25.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2022-01-14 09:43:25
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a>
</div>


    <div id="/2022/01/14/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/" class="leancloud_visitors post__stat" data-flag-title="输入输出管理">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#I-x2F-O%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80"><span class="post__toc-text">I&#x2F;O管理基础</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%AE%BE%E5%A4%87"><span class="post__toc-text">设备</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="post__toc-text">I&#x2F;O控制方式</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#I-x2F-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="post__toc-text">I&#x2F;O软件层次结构</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="post__toc-text">输入输出应用程序接口</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E8%BD%AF%E4%BB%B6"><span class="post__toc-text">设备独立软件</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="post__toc-text">缓冲区管理</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="post__toc-text">设备分配与回收</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AFSPOOLing"><span class="post__toc-text">假脱机技术SPOOLing</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="post__toc-text">设备驱动程序接口</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86"><span class="post__toc-text">外存管理</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E7%A3%81%E7%9B%98"><span class="post__toc-text">磁盘</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="post__toc-text">固态硬盘</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E7%A3%81%E5%B8%A6%E6%9C%BA%E4%B8%8D%E6%98%AF%E5%85%B1%E4%BA%AB%E8%AE%BE%E5%A4%87%EF%BC%8C%E5%8F%AA%E8%83%BD%E9%87%87%E7%94%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="post__toc-text">磁带机不是共享设备，只能采用顺序存储结构</span></a></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h2 id="I-x2F-O管理基础"><a href="#I-x2F-O管理基础" class="headerlink" title="I&#x2F;O管理基础"></a>I&#x2F;O管理基础</h2><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><ul>
<li><p>设备的基本概念</p>
<ul>
<li>UNIX系统中，所有设备均视为特殊文件</li>
</ul>
</li>
<li><p>设备的分类</p>
<ul>
<li><p>使用特性</p>
<ul>
<li><p>人机交互类外部设备</p>
<ul>
<li><p>键鼠</p>
<ul>
<li>传输速度慢</li>
</ul>
</li>
</ul>
</li>
<li><p>网路通信设备</p>
<ul>
<li><p>路由器</p>
<ul>
<li>中等</li>
</ul>
</li>
</ul>
</li>
<li><p>存储设备</p>
<ul>
<li><p>移动硬盘、光盘</p>
<ul>
<li>快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>传输速率</p>
<ul>
<li><p>低速设备</p>
<ul>
<li>键鼠</li>
</ul>
</li>
<li><p>中速设备</p>
<ul>
<li>激光打印机</li>
</ul>
</li>
<li><p>高速设备</p>
<ul>
<li>磁盘</li>
</ul>
</li>
</ul>
</li>
<li><p>信息交换单位</p>
<ul>
<li><p>块设备</p>
<ul>
<li><p>磁盘</p>
<ul>
<li>快，可寻址(随机读写，基本特征)</li>
</ul>
</li>
</ul>
</li>
<li><p>字符设备</p>
<ul>
<li><p>键鼠</p>
<ul>
<li>慢，不可寻址，中断驱动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>I&#x2F;O控制器</p>
<ul>
<li><p>I&#x2F;O设备</p>
<ul>
<li><p>机械部件</p>
<ul>
<li>执行具体I&#x2F;O操作（显示屏、按钮、磁臂）</li>
</ul>
</li>
<li><p>电子部件</p>
<ul>
<li><p>电路板(&#x3D;I&#x2F;O控制器)</p>
<ul>
<li>中介，OS通过电子部件控制机械部件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li><p>接受和识别CPU发出的命令</p>
<ul>
<li><p>控制寄存器</p>
<ul>
<li>存放命令(read&#x2F;write)和参数</li>
</ul>
</li>
</ul>
</li>
<li><p>向CPU报告设备状态</p>
<ul>
<li><p>状态寄存器</p>
<ul>
<li>1空闲&#x2F;0忙碌</li>
</ul>
</li>
</ul>
</li>
<li><p>数据交换</p>
<ul>
<li><p>数据寄存器</p>
<ul>
<li>暂存CPU要和设备间交换的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>地址识别</p>
<ul>
<li>为每个寄存器设一个地址，让CPU知道自己是谁</li>
</ul>
</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li><p>CPU与控制器接口</p>
<ul>
<li><p>数据、状态、控制寄存器，有多个，要编址</p>
<ul>
<li><p>内存映像I&#x2F;O</p>
<ul>
<li>与内存统一编址，简化指令</li>
</ul>
</li>
<li><p>寄存器独立编址</p>
<ul>
<li>从0开始，需专门指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>I&#x2F;O逻辑</p>
<ul>
<li><p>接收、识别、发出命令</p>
<ul>
<li>即设备控制器。每种设备对应的设备控制器都对应一组控制命令，CPU通过控制命令控制控制设备器</li>
</ul>
</li>
</ul>
</li>
<li><p>控制器与设备接口</p>
<ul>
<li>每个接口中都存在数据、控制、状态三种信号，一个接口连接一台设备</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><ul>
<li><p>程序直接控制方式(轮询方式)</p>
<ul>
<li><p>完成一次读&#x2F;写操作的流程</p>
<ul>
<li>CPU向控制器发出读指令，等设备启动、状态设为1</li>
<li>轮询检查状态寄存器，为1则准备好</li>
<li>设备准备好后上传数据和状态</li>
<li>控制器将数据放到数据寄存器中，将状态改为0</li>
<li>CPU发现就绪，读入数据并放入CPU的寄存器中，再放入内存</li>
</ul>
</li>
<li><p>CPU干预频率</p>
<ul>
<li>很频繁</li>
</ul>
</li>
<li><p>数据传送单位</p>
<ul>
<li>每次读或写1个字</li>
</ul>
</li>
<li><p>数据流向</p>
<ul>
<li><p>读</p>
<ul>
<li>I&#x2F;O→CPU→内存</li>
</ul>
</li>
<li><p>写</p>
<ul>
<li>内存→CPU→I&#x2F;O</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>实现简单</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>CPU与I&#x2F;O串行，“忙等”，CPU利用率低</li>
</ul>
</li>
</ul>
</li>
<li><p>中断驱动方式</p>
<ul>
<li><p>完成一次读&#x2F;写操作的流程</p>
<ul>
<li>CPU发出指令后，阻塞请求I&#x2F;O进程，切换到别的进程，I&#x2F;O完成后，设备发中断信号</li>
<li>CPU在每个指令周期末尾检查中断</li>
<li>中断处理中需保存、恢复环境，需要时间开销，所以中断不能太频繁</li>
</ul>
</li>
<li><p>CPU干预频率</p>
<ul>
<li>在每次I&#x2F;O开始前，结束后介入</li>
</ul>
</li>
<li><p>数据传送单位</p>
<ul>
<li>一个字</li>
</ul>
</li>
<li><p>数据流向</p>
<ul>
<li><p>读</p>
<ul>
<li>I&#x2F;O→CPU→内存</li>
</ul>
</li>
<li><p>写</p>
<ul>
<li>内存→CPU→I&#x2F;O</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>CPU，I&#x2F;O并行，提升利用率</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>频繁中断（每个字都要中断）太耗时</li>
</ul>
</li>
</ul>
</li>
<li><p>DMA方式(直接存储器存取)</p>
<ul>
<li><p>DMA也是一种I&#x2F;O控制器，比一般的多了DR(数据寄存器)、MAR(内存位置)、DC(计数器,记剩余字数)、CR(命令状态寄存器)，主要用于块设备的I&#x2F;O</p>
</li>
<li><p>完成一次读&#x2F;写操作的流程</p>
<ul>
<li>CPU给I&#x2F;O模块发指令，DMA读&#x2F;写，传输完成后发出中断，CPU读DMA</li>
</ul>
</li>
<li><p>CPU干预频率</p>
<ul>
<li>CPU仅在一个或多个数据块传输开始和结束时干预</li>
</ul>
</li>
<li><p>数据传送单位</p>
<ul>
<li>DMA每次一个字，CPU每次一个或多个连续块（在内存中也连续存放）</li>
</ul>
</li>
<li><p>数据流向</p>
<ul>
<li><p>读</p>
<ul>
<li>I&#x2F;O→内存</li>
</ul>
</li>
<li><p>写</p>
<ul>
<li>内存→I&#x2F;O</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>以块为单位，提高并行性，增加数据传输效率</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>不能读离散数据块</li>
</ul>
</li>
</ul>
</li>
<li><p>通道控制方式</p>
<ul>
<li><p>字节多路通道用作连接大量低速或中速I&#x2F;O设备，编制好的通道程序放在主存中</p>
</li>
<li><p>完成一次读&#x2F;写操作的流程</p>
<ul>
<li>CPU向通道发送任务清单在内存中的位置，之后由通道接管，完成后中断</li>
</ul>
</li>
<li><p>CPU干预频率</p>
<ul>
<li>极低，完成一组数据块后才需要CPU</li>
</ul>
</li>
<li><p>数据传送单位</p>
<ul>
<li>一组数据块</li>
</ul>
</li>
<li><p>数据流向</p>
<ul>
<li><p>读</p>
<ul>
<li>I&#x2F;O→内存</li>
</ul>
</li>
<li><p>写</p>
<ul>
<li>内存→I&#x2F;O</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>CPU、通道、I&#x2F;O可并行工作，资源利用率很高</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>复杂，需专门硬件支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-x2F-O软件层次结构"><a href="#I-x2F-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h3><ul>
<li><p>（库函数）</p>
</li>
<li><p>用户层I&#x2F;O软件</p>
<ul>
<li><p>实现与用户交互的接口，提供库函数</p>
<ul>
<li>SPOOLing技术</li>
</ul>
</li>
</ul>
</li>
<li><p>（系统调用）</p>
<ul>
<li>提供系统调用的接口(也叫系统调用处理层)</li>
</ul>
</li>
<li><p>设备独立性软件</p>
<ul>
<li><p>设备无关性软件</p>
<ul>
<li><p>向上提供系统调用接口</p>
<ul>
<li>将系统调用参数翻译成设备操作命令</li>
</ul>
</li>
<li><p>I&#x2F;O调度</p>
<ul>
<li>用某种算法确定一个好的顺序来处理各I&#x2F;O请求（磁盘调度算法）</li>
</ul>
</li>
<li><p>设备的保护</p>
<ul>
<li>设备作为特殊文件，有自己的FCB，OS根据FCB中的信息查看用户对设备的访问权限</li>
</ul>
</li>
<li><p>差错处理(设备出错)</p>
</li>
<li><p>设备的分配与回收</p>
</li>
<li><p>数据缓冲区的管理</p>
</li>
<li><p>建立逻辑设备名到物理设备名的映射</p>
<ul>
<li><p><strong>逻辑设备表LUT：逻辑名|物理名|驱动程序入口地址</strong></p>
</li>
<li><p>LUT</p>
<ul>
<li>整个系统一张(单用户)</li>
<li>每个用户一张</li>
</ul>
</li>
<li><p>打印机1|3|10*</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设备驱动程序</p>
<ul>
<li>设置设备寄存器，检查设备状态</li>
<li>计算数据所在磁盘的柱面号、磁头号、扇区号</li>
<li>执行OS发出的I&#x2F;O命令</li>
</ul>
</li>
<li><p>中断处理程序</p>
<ul>
<li>由中断自行处理</li>
</ul>
</li>
<li><p>硬件</p>
<ul>
<li>不同设备有不同的硬件特性，厂家设计并提供驱动程序(在系统中以独立进程的方式存在)</li>
</ul>
</li>
</ul>
<h3 id="输入输出应用程序接口"><a href="#输入输出应用程序接口" class="headerlink" title="输入输出应用程序接口"></a>输入输出应用程序接口</h3><ul>
<li><p>字符设备接口</p>
<ul>
<li><p>数据存取和传输是以字符为单位的设备</p>
<ul>
<li>键盘、打印机</li>
</ul>
</li>
<li><p>基本特征</p>
<ul>
<li>传输速率较低，不可寻址，在I&#x2F;O时采用中断驱动方式</li>
</ul>
</li>
<li><p>get和put操作</p>
<ul>
<li>字符设备只能采取顺序存取方式。为字符设备建立一个字符缓冲区，用户通过get操作从缓冲区获取字符，通过put操作输出字符到缓冲区</li>
</ul>
</li>
<li><p>in-control执行</p>
<ul>
<li>在接口提供一种通用in-control指令来处理种类繁多的字符设备（包含许多参数，每个参数表示一个与具体设备相关的特定功能）</li>
</ul>
</li>
<li><p>字符设备都属于独占设备，接口中必须提供打开和关闭操作，以实现互斥共享</p>
</li>
</ul>
</li>
<li><p>块设备接口</p>
<ul>
<li><p>数据的存取和传输是以数据块为单位的设备</p>
<ul>
<li>磁盘</li>
</ul>
</li>
<li><p>基本特征</p>
<ul>
<li>传输速率较高，可寻址，I&#x2F;O采用DMA方式</li>
</ul>
</li>
<li><p>隐藏了磁盘的二维结构（磁道号，扇区号），将所有扇区从0到n-1编号，成为一种线性序列</p>
</li>
<li><p>将抽象命令映射为低层操作</p>
<ul>
<li>块设备接口支持上层发来的对文件过设备的打开、读、写等抽象命令，该接口将上述命令映射为设备能识别的较低层的具体操作</li>
</ul>
</li>
</ul>
</li>
<li><p>网络设备接口</p>
<ul>
<li>现代操作系统都提供了面向网络的功能，因此也须提供相应的网络软件和网络通信接口，使计算机能通过网络与网络上的其它计算机进行通信或上网浏览。</li>
<li>许多操作系统提供的网络IO接口为网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字，连接到远程应用程序创建的套接字，通过此连接发送和接收数据。</li>
</ul>
</li>
<li><p>阻塞&#x2F;非阻塞I&#x2F;O</p>
<ul>
<li><p>阻塞IO</p>
<ul>
<li>指当用户进程调用IO操作时，进程就被阻塞，需要等待IO操作完成，进程才被唤醒继续执行。</li>
</ul>
</li>
<li><p>非阻塞IO</p>
<ul>
<li>指用户进程调用I&#x2F;O操作时，不阻塞该进程，该IO调用返回一个错误返回值，通常，进程需要通过轮询的方式来查询IO操作是否完成。</li>
<li>大多数操作系统提供的I&#x2F;O接口都是采用阻塞IO。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="设备独立软件"><a href="#设备独立软件" class="headerlink" title="设备独立软件"></a>设备独立软件</h2><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><ul>
<li><p>缓冲区可以由专门的硬件寄存器组成，也可以用内存作缓冲区（更多，这里特指）</p>
</li>
<li><p>缓冲区的作用</p>
<ul>
<li><p>缓和CPU和I&#x2F;O之间速度差异</p>
</li>
<li><p>减少CPU中断频率，放宽对CPU中断响应时间的限制</p>
</li>
<li><p>解决数据粒度不匹配的问题</p>
<ul>
<li>输入进程一次一块，I&#x2F;O一次一个字</li>
</ul>
</li>
<li><p>提高CPU与I&#x2F;O的并行性</p>
</li>
</ul>
</li>
<li><p>缓冲技术(策略)</p>
<ul>
<li><p>单缓冲</p>
<ul>
<li><p>在进程请求时，OS会在主存中为其分配一个缓冲区，大小一般为一块</p>
<ul>
<li>专用缓冲</li>
</ul>
</li>
<li><p>当缓冲区Buffer非空时，不能放入数据，只能传出；当Buffer为空时，可以放入，必须放满后才能传出</p>
</li>
<li><p>每处理一块数据平均需要多久？</p>
<ul>
<li><p>块设备→缓冲区输入时间T</p>
<ul>
<li><p>缓冲区→用户进程工作区传送时间M</p>
<ul>
<li>用户进程工作区→CPU处理时间C</li>
</ul>
</li>
</ul>
</li>
<li><p>假设初始状态为工作区满，缓冲区空→下一次此状态</p>
<ul>
<li><p>if T&gt;C</p>
<ul>
<li><p>CPU处理完后不能传下一块，要等T结束</p>
<ul>
<li>T+M</li>
</ul>
</li>
</ul>
</li>
<li><p>if T&lt;C</p>
<ul>
<li><p>设备传完一块不能传下一块，等C结束</p>
<ul>
<li>C+M</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Max(C,T) +M</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>双缓冲</p>
<ul>
<li><p>OS在主存中为进程分配两个缓冲区，一个大小一块</p>
<ul>
<li>专用缓冲</li>
</ul>
</li>
<li><p>处理一块数据所需时间</p>
<ul>
<li><p>初始状态设为一个满，一个空</p>
<ul>
<li><p>if T&gt;M+C</p>
<ul>
<li><p>可使块设备连续输入</p>
<ul>
<li>T</li>
</ul>
</li>
</ul>
</li>
<li><p>if T&lt;M+C</p>
<ul>
<li><p>可使CPU不用等待设备输入</p>
<ul>
<li>M+C，回不到初始状态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Max(T,C+M)</p>
</li>
</ul>
</li>
<li><p>单双缓冲也可以用于两台机器通信，消息放入缓冲区，单只能单向传输</p>
<ul>
<li>管道通信中的管道就是缓冲区</li>
</ul>
</li>
</ul>
</li>
<li><p>循环缓冲</p>
<ul>
<li>将多个大小相等的缓冲区链接成一个循环队列</li>
</ul>
</li>
<li><p>缓冲池</p>
<ul>
<li><p>由多个系统公用的缓冲区组成</p>
<ul>
<li>系统共用资源，供多个进程共享</li>
</ul>
</li>
<li><p>按使用状况</p>
<ul>
<li>空缓冲队列</li>
<li>输入队列</li>
<li>输出队列</li>
</ul>
</li>
<li><p>四种工作缓冲区</p>
<ul>
<li>收容输出</li>
<li>提取输出</li>
<li>提取输入</li>
<li>收容输出</li>
</ul>
</li>
<li><p>流程：</p>
<ul>
<li><p>输入进程需要输入数据</p>
<ul>
<li>从空缓冲队列的队首摘下一个空缓冲区，作为收容输入的工作缓冲区→把输入数据输入其中→装满后，挂到输入队列队尾</li>
</ul>
</li>
<li><p>计算进程需要输入数据</p>
<ul>
<li>从输入队列取得一个缓冲区，作为提取输入的工作缓冲区→计算进程从中提取数据→数据用完后再挂到空缓冲队列队尾</li>
</ul>
</li>
<li><p>计算进程需要输出数据</p>
<ul>
<li>从空缓冲队列的队首取得一个空缓冲区，作为收容输出→装满后挂到输出队列队尾</li>
</ul>
</li>
<li><p>输出进程需要输出数据</p>
<ul>
<li>从输出队列取得一个装满数据的缓冲区，作为提取输出→数据提取完后挂到空缓冲队列队尾</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h3><ul>
<li><p>设备分配时应考虑的因素</p>
<ul>
<li><p>设备的固有属性</p>
<ul>
<li>独占设备、共享设备、虚拟设备</li>
</ul>
</li>
<li><p>设备的分配算法</p>
<ul>
<li>先来先服务、优先级高</li>
</ul>
</li>
<li><p>设备分配中的安全性</p>
<ul>
<li><p>安全分配方式</p>
<ul>
<li>为进程分配一个设备后就将其阻塞，I&#x2F;O完成后唤醒</li>
<li>破坏“请求与保持”条件，不会死锁；CPU和I&#x2F;O只能串行工作</li>
</ul>
</li>
<li><p>不安全分配方式</p>
<ul>
<li>I&#x2F;O请求得不到满足时才阻塞</li>
<li>可并行；会死锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设备分配方式</p>
<ul>
<li><p>静态分配</p>
<ul>
<li><p>进程运行前为其分配全部所需资源，结束后归还</p>
<ul>
<li>破坏“请求与保持”条件，不会死锁</li>
</ul>
</li>
</ul>
</li>
<li><p>动态分配</p>
<ul>
<li>进程运行中动态分配</li>
</ul>
</li>
</ul>
</li>
<li><p>设备分配管理中的数据结构</p>
<ul>
<li><p>为了表示 【系统1→n通道1→n控制器1→n设备】</p>
</li>
<li><p><strong>系统设备表SDT</strong></p>
<ul>
<li><p><strong>表目|设备类型|设备标识符|DCT|驱动程序入口</strong></p>
<ul>
<li>整个系统只有一张，每个设备占一个表目</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>设备控制表DCT</strong></p>
<ul>
<li><p><strong>设备类型|设备标识符|设备状态|指向控制器的指针|重复执行次数或时间|设备队列首指针</strong></p>
<ul>
<li>一个DCT代表一个设备</li>
<li>重复执行多次不成功则认为I&#x2F;O失败</li>
<li>设备队列中为等待设备的进程队列PCB</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>控制器控制表COCT</strong></p>
<ul>
<li><p><strong>控制器标识符|控制器状态|指向通道表指针|控制器队列队首指针|控制器队列队尾指针</strong></p>
<ul>
<li>状态：故障&#x2F;空闲&#x2F;忙碌</li>
<li>控制器队列：等待控制器的进程队列</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>通道控制表CHCT</strong></p>
<ul>
<li><p><strong>通道标识符|通道状态|与通道连接的COCT首址|通道队列队首指针|通道队列队尾指针</strong></p>
<ul>
<li>一个通道对应多个控制器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设备分配的步骤</p>
<ul>
<li><p>根据进程请求的物理设备名查SDT→DCT（设备忙则进入设备等待队列）→COCT（忙则进入控制器等待队列）→CHCT（忙则进入通道等待队列）</p>
<ul>
<li>三者都分配后才算分配成功，才能启动I&#x2F;O设备传送数据</li>
<li>缺点：用户必须用物理设备名；换设备则无法运行（若请求的设备在忙，也用不了其他同类设备）</li>
</ul>
</li>
<li><p>改进：LUT</p>
</li>
</ul>
</li>
</ul>
<h3 id="假脱机技术SPOOLing"><a href="#假脱机技术SPOOLing" class="headerlink" title="假脱机技术SPOOLing"></a>假脱机技术SPOOLing</h3><ul>
<li><p>早期使用纸带，CPU直接与I&#x2F;O相连</p>
<ul>
<li><p>批处理阶段引入脱机输入&#x2F;输出技术（用磁带(外围控制机)完成）</p>
<ul>
<li>SPOOLing：用软件的方式模拟脱机技术，不需外围计算机</li>
</ul>
</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li><p>在磁盘上开辟出两个存储区域</p>
<ul>
<li><p>输入井</p>
<ul>
<li>模拟脱机输入时的磁带，收容I&#x2F;O设备输入的数据</li>
</ul>
</li>
<li><p>输出井</p>
<ul>
<li>模拟输出磁带，收容用户进程输出的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>内存有</p>
<ul>
<li><p>输入进程</p>
<ul>
<li>模拟输入时的外围控制机</li>
</ul>
</li>
<li><p>输出进程</p>
<ul>
<li>模拟输出时的外围控制机</li>
</ul>
</li>
</ul>
</li>
<li><p>内存开辟</p>
<ul>
<li><p>输入缓冲区</p>
<ul>
<li>在输入进程控制下，用于暂存从输入设备输入的数据，之后再转存到输入井</li>
</ul>
</li>
<li><p>输出缓冲区</p>
<ul>
<li>在输出进程控制下，用于暂存从输出井送来的数据，之后再送到输出设备</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SPOOLing改造</p>
<ul>
<li><p>独占式设备</p>
<ul>
<li><p>只允许进程串行使用</p>
<ul>
<li><p>打印机</p>
<ul>
<li>每个进程提出打印请求时，OS都会为其在输出井中分配一个存储区，使进程觉得自己独占打印机（相当于分配逻辑设备）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>共享设备</p>
<ul>
<li><p>允许多个进程同时使用（宏观）</p>
<ul>
<li>必须是可寻址和可随机访问的设备</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备驱动程序接口"><a href="#设备驱动程序接口" class="headerlink" title="设备驱动程序接口"></a>设备驱动程序接口</h3><ul>
<li><p>要求每个设备驱动程序与操作系统之间都有着相同的、或接近的接口</p>
<ul>
<li>易于添加新的设备驱动程序，方便开发人员编制设备驱动程序</li>
</ul>
</li>
<li><p>对于每一种设备类型，例如磁盘，操作系统定义一组驱动程序必须支持的函数。对磁盘而言,这些函数自然包含读、写、格式化等。驱动程序中通常包含一张表格，这张表格具有针对这些函数指向驱动程序自身的指针。当驱动程序装载时，操作系统记录下这张函数指针表的地址，所以当操作系统需要调用一个函数时，它可以通过这张表格发出间接调用。这张函数指针表定义了驱动程序与操作系统其余部分之间的接口。给定类型的所有设备都必须服从这一要求。</p>
</li>
<li><p>与设备无关的软件还要负责把符号化的设备名映射到适当的驱动程序上。例如，在UNIX中，设备名&#x2F;dev&#x2F;disk0唯一确定了一个特殊文件的i节点，这个i节点包含了主设备号（用于定位相应的驱动程序）和次设备号（用来确定要读写的具体设备）</p>
</li>
<li><p>在UNIX和 Windows 中，设备使作为命名对象出现在文件系统中的，因此针对文件的常规保护规则也适用于I&#x2F;O设备。系统管理员可以为每一个设备设置适当的访问权限</p>
</li>
</ul>
<h2 id="外存管理"><a href="#外存管理" class="headerlink" title="外存管理"></a>外存管理</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ul>
<li><p>磁盘结构</p>
<ul>
<li><p>磁盘、磁道、扇区</p>
<ul>
<li>定位磁盘块（柱面号(磁道)，盘面号，扇区号）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> (访问连续地址动得少)</p>
<pre><code>- 分类

    - 活动头磁盘

        - 磁头来回伸缩

    - 固定头磁盘

        - 每个磁道一个磁头

    - 可换盘磁盘

        - 磁盘可以移动和替换

    - 固定盘磁盘

        - 磁盘永久固定在磁盘驱动器中
</code></pre>
<ul>
<li><p>格式化</p>
<ul>
<li><p>格式化</p>
<ul>
<li><p>低级格式化(物理格式化)</p>
<ul>
<li>将磁盘分为扇区，一个扇区分为头、数据区、尾。头尾用来放校验码，尾有指向下一扇区指针</li>
</ul>
</li>
<li><p>将磁盘分区，每个分区由若干柱面组成</p>
<ul>
<li>分C、D、E盘，是同心圆</li>
</ul>
</li>
<li><p>逻辑格式化</p>
<ul>
<li>创建文件系统（包括根目录，初始化存储空间所用数据结构(位示图、空闲分区表)）</li>
</ul>
</li>
</ul>
</li>
<li><p>引导块</p>
<ul>
<li><p>开机需进行初始化，初始化工作由执行初始化程序(自举程序)完成</p>
</li>
<li><p>全部转入ROM</p>
<ul>
<li>自举程序不可改</li>
</ul>
</li>
<li><p>ROM中存放很小的“自举转入程序”，开机运行，找到在磁盘启动块(引导块&#x2F;启动分区(启动磁盘或系统磁盘(C盘)))的完整程序，读入内存</p>
<ul>
<li>自举程序可更改</li>
</ul>
</li>
</ul>
</li>
<li><p>坏块的管理</p>
<ul>
<li><p>坏块：无法正常使用的扇区，属于硬件故障，OS无法修复</p>
</li>
<li><p>简单磁盘</p>
<ul>
<li><p>在逻辑格式化时对磁盘进行坏块检查，表明坏扇区(可在FAT中)</p>
<ul>
<li>坏块对OS不透明</li>
</ul>
</li>
</ul>
</li>
<li><p>复杂磁盘</p>
<ul>
<li><p>磁盘控制器(磁盘内部的一个硬件)会维护一个坏块链表。在出厂前进行物理格式化时，初始化坏块链，保留一些备用扇区，用来替换坏块</p>
<ul>
<li>对OS透明</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘调度方法</p>
<ul>
<li><p>一次磁盘读&#x2F;写所花时间</p>
<ul>
<li><p>寻道时间Ts</p>
<ul>
<li>启动磁头臂消耗s；移动磁头，跨越一磁道耗时m，共需跨越n条</li>
<li>Ts&#x3D;s+mn</li>
</ul>
</li>
<li><p>延迟时间Tr</p>
<ul>
<li>旋转磁盘，找到目标扇区的时间。磁盘转速&#x3D;r(转&#x2F;s)，典型转速为5400转&#x2F;分</li>
<li>Tr&#x3D;1&#x2F;2r（平均需转半圈）</li>
</ul>
</li>
<li><p>传输时间Tt</p>
<ul>
<li>读出&#x2F;写入时间。读写字节数为b，每个磁盘字节数为N，b&#x2F;n&#x3D;要访问的总磁道数</li>
<li>Tt&#x3D;1&#x2F;r×b&#x2F;N&#x3D;b&#x2F;rN</li>
</ul>
</li>
</ul>
</li>
<li><p>先来先服务算法</p>
<ul>
<li><p>按进程达到顺序移动磁头</p>
<ul>
<li>平均寻找长度&#x3D;总移动磁道数 &#x2F; 进程数</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>公平，访问磁道集中的情况下，性能还行</p>
<ul>
<li>不会导致磁臂黏着</li>
<li>某个进程或某几个进程对某一磁道有较高的 访问频率，这些进程反复对该磁道I&#x2F;O，从而垄断整个磁盘设备</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>大量分散进程时，FCFS性能很差，寻道时间长，近似随机调度</li>
</ul>
</li>
</ul>
</li>
<li><p>最短寻找时间优先</p>
<ul>
<li><p>优先处理和当前磁道最近磁道（贪心算法，眼前最优未必是总体最优）</p>
</li>
<li><p>优点</p>
<ul>
<li>性能较好</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>可能饥饿（磁头只在小范围移动）</li>
</ul>
</li>
</ul>
</li>
<li><p>扫描算法（电梯算法）</p>
<ul>
<li><p>磁头移动到最外侧才能向内移动(只增大)，移动到最内侧才能向外移动(只减小)</p>
</li>
<li><p>优点</p>
<ul>
<li>性能较好，平均寻道时间较短（仅次于SSTF），不会饥饿</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>只有到两端才能改变方向，可能实际用不到最外&#x2F;内侧</li>
<li>响应各位置磁道的响应频率不平均</li>
</ul>
</li>
</ul>
</li>
<li><p>LOOK调度算法</p>
<ul>
<li><p>在移动方向上已无请求，则立刻改变移动方向（边动边观察）</p>
</li>
<li><p>优点</p>
<ul>
<li>寻道时间比SCAN短</li>
</ul>
</li>
</ul>
</li>
<li><p>循环扫描算法</p>
<ul>
<li><p>移动到最外&#x2F;内返回时，直接回到起点而不处理请求（只在一个方向上响应请求）</p>
</li>
<li><p>优点</p>
<ul>
<li>响应频率比SCAN平均</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>SCAN的缺点1还在</li>
<li>寻道时间比SCAN长</li>
<li>会导致磁臂黏着</li>
</ul>
</li>
</ul>
</li>
<li><p>C-LOOK算法</p>
<ul>
<li>磁头移动方向已无请求，立即返回至有请求的位置</li>
<li>优点：解决缺点1</li>
</ul>
</li>
</ul>
</li>
<li><p>减少磁盘延迟时间Tr的方法</p>
<ul>
<li><p>与调度算法无关，取决于磁盘空闲空间分配程序，与文件物理结构有关</p>
</li>
<li><p>磁头读取扇区后需要处理时间，无法马上读入相邻扇区（逻辑相邻&#x3D;物理相邻时），此时要等盘面再转一圈回到此相邻扇区，需要很长的延迟时间</p>
</li>
<li><p>方法</p>
<ul>
<li><p>交替编号(同一盘面扇区)</p>
<ul>
<li>让逻辑相邻的在物理上有一定间隔</li>
</ul>
</li>
<li><p>错位命名(不同盘面扇区)</p>
<ul>
<li>上一盘面读完后可以过段时间在读到下一盘面地址相邻扇区 (0,0,111)→(0,1,000)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分区</p>
</li>
</ul>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><ul>
<li>读写性能特性</li>
<li>磨损均衡</li>
</ul>
<h3 id="磁带机不是共享设备，只能采用顺序存储结构"><a href="#磁带机不是共享设备，只能采用顺序存储结构" class="headerlink" title="磁带机不是共享设备，只能采用顺序存储结构"></a>磁带机不是共享设备，只能采用顺序存储结构</h3>
  </div>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2022
  BONE
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/FloatinDLE"><i class="blogfont">&#xe6b7; </i></a>
  
    <a class="social-links" href="mailto:bone_n@foxmail.com"><i class="blogfont">&#xe61a; </i></a>
  
    <a class="social-links" href="/atom.xml"><i class="blogfont">&#xe640; </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>