<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/kou.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>地下室 内存管理 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 5.4.1"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <!-- <a class="menu__item" href="/">作品</a> -->
    <!-- <a class="menu__item" href="/about/">关于</a> -->
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">内存管理</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2022-01-12T01:43:25.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2022-01-12 09:43:25
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">-计算机基础</a>
</div>


    <div id="/2022/01/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="leancloud_visitors post__stat" data-flag-title="内存管理">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80"><span class="post__toc-text">内存管理基础</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="post__toc-text">创建进程</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="post__toc-text">逻辑地址空间与物理地址空间</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="post__toc-text">内存管理的功能</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="post__toc-text">虚拟内存管理</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post__toc-text">虚拟内存的基本概念</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="post__toc-text">请求页式管理</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="post__toc-text">页面置换算法</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="post__toc-text">页框分配策略</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="post__toc-text">内存映射文件</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0%E5%8F%8A%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95"><span class="post__toc-text">虚拟存储器性能的影响因素及改进方法</span></a></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><ul>
<li><p>编译</p>
<ul>
<li>编译程序，将源代码编译成若干目标模块</li>
</ul>
</li>
<li><p>链接</p>
<ul>
<li><p>将编译后形成的目标模块与库函数连接在一起，形成完整的装入模块</p>
<ul>
<li><p>静态链接</p>
<ul>
<li>运行前完整链接，不再拆开</li>
</ul>
</li>
<li><p>装入时动态链接</p>
<ul>
<li>边装入边链接</li>
</ul>
</li>
<li><p>运行时动态链接</p>
<ul>
<li><p>执行中需要时才链接</p>
<ul>
<li>便于修改和更新，便于共享目标模块</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>装入</p>
<ul>
<li><p>将装入模块装入内存运行</p>
<ul>
<li><p>绝对装入</p>
<ul>
<li><p>编译程序产生绝对地址的目标代码，不需修改程序和数据地址</p>
<ul>
<li>只适用于单道程序环境</li>
</ul>
</li>
</ul>
</li>
<li><p>可重定位装入静态重定位</p>
<ul>
<li><p>每个目标模块的起始地址都为0，其他地址相对于始址，装入时一次性修改完指令和数据地址</p>
<ul>
<li>作业装入时必须为它分配所需全部内存，否则不能装入。装入后不能移动和申请新空间</li>
</ul>
</li>
</ul>
</li>
<li><p>动态运行时装入动态重定位</p>
<ul>
<li><p>装入内存后所有地址为相对地址，程序真正执行时才转换为绝对地址，需要重定位寄存器</p>
<ul>
<li>可以分配到不连续空间；装入部分代码即可运行，运行时动态申请空间；便于共享程序段；可以提供大于存储空间的地址空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h3><ul>
<li><p>逻辑地址相对地址</p>
<ul>
<li>每个模块从0编址，用户和程序员只知道逻辑地址，系统编程人员才知道具体地址。不同进程可以拥有相同逻辑地址</li>
</ul>
</li>
<li><p>物理地址空间</p>
<ul>
<li>内存中物理单元的集合，逻辑地址→物理地址:地址重定位</li>
</ul>
</li>
</ul>
<h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><ul>
<li><p>地址变换</p>
</li>
<li><p>扩充内存</p>
<ul>
<li><p>覆盖</p>
<ul>
<li><p>将程序分为多个段，常用段常驻内存“固定区”，不常用段在需要时调入内存“覆盖区”（多个，不可能同时访问的可放在同一个区）</p>
<ul>
<li>早期操作系统，对用户不透明，必须由程序员声明覆盖结构；同时运行的程序总代码量大于主存时仍不能运行</li>
<li>同一进程或程序</li>
</ul>
</li>
</ul>
</li>
<li><p>交换</p>
<ul>
<li><p>内存紧张时，系统将处于等待状态的程序换出（挂起，到辅存），将外存已具备运行条件的换入内存。中级调度</p>
<ul>
<li><p>不同进程或作业之间</p>
</li>
<li><p>内存分为对换区(小，连续分配，快)和文件区(大，离散分配，慢)</p>
<ul>
<li>对外存对换区的管理以提高换入换出速度为主要目标</li>
</ul>
</li>
<li><p>所有进程PCB会常驻内存</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟存储技术</p>
</li>
</ul>
</li>
<li><p>内存共享</p>
<ul>
<li><p>允许多个进程访问内存的同一部分</p>
<ul>
<li>内存管理必须支持对内存共享区域进行受控访问</li>
</ul>
</li>
</ul>
</li>
<li><p>内存保护</p>
<ul>
<li><p>在CPU中设置一对上下限寄存器，存放用户作业在主存中的上下限地址，每次访问地址时比较寄存器中的值，判断是否越界</p>
</li>
<li><p>采用重定位寄存器（基址寄存器，存放最小物理地址值）和界地址寄存器（限长寄存器，存放逻辑地址最大值）。比较逻辑地址和界地址寄存器中的值，未越界则加上重定位寄存器中的值形成物理地址。</p>
<ul>
<li>切换不同进程要更新两个寄存器中的值</li>
</ul>
</li>
<li><p>程序保护</p>
<ul>
<li><p>栈保护</p>
<ul>
<li>缓冲区溢出攻击缓解手段</li>
</ul>
</li>
<li><p>数据执行保护</p>
<ul>
<li>将数据所在内存页表为不可执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内存分配与回收</p>
<ul>
<li><p>连续分配管理方式</p>
<ul>
<li><p>单一连续分配</p>
<ul>
<li><p>分区</p>
<ul>
<li>内存分为系统区和用户区。系统区仅供OS使用，通常在低地址；用户区是为用户提供的。</li>
</ul>
</li>
<li><p>分配</p>
<ul>
<li>无需内存保护，内存中永远只有一道程序</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>简单，无外部碎片，可以采用覆盖技术，无需额外技术支持</li>
<li>只能用于单用户单任务的操作系统；   有内部碎片，存储器利用率极低</li>
</ul>
</li>
</ul>
</li>
<li><p>固定分区分配</p>
<ul>
<li><p>分区</p>
<ul>
<li><p>将用户区分为若干区域，每个分区只装入一道作业</p>
<ul>
<li><p>分区大小相等</p>
<ul>
<li>缺乏灵活性</li>
</ul>
</li>
<li><p>分区大小不等</p>
<ul>
<li>多个小分区，适量中分区，少量大分区</li>
<li><strong>分区说明表[分区号|大小|始址|状态(是否已分配)]</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分配</p>
<ul>
<li>有程序要装入时检索表，找到合适分区并修改状态，未找到则拒绝分配</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>最简单的多道程序内存管理方式，无外部碎片</li>
<li>程序态大放不进分区，要使用覆盖技术，降低性能；主存利用率小，会产生内部碎片</li>
</ul>
</li>
</ul>
</li>
<li><p>动态分区分配</p>
<ul>
<li><p>分区</p>
<ul>
<li><p>不预先划分内存，在装入时动态建立分区，分区大小数目可变</p>
</li>
<li><p><strong>空闲分区表(只有空的)</strong></p>
<ul>
<li><strong>分区号|分区大小|起始地址|状态</strong></li>
</ul>
</li>
<li><p><strong>空闲分区链</strong></p>
<ul>
<li>每个分区有 起始指针（记录大小信息）和末尾指针（指向下一分区）</li>
</ul>
</li>
</ul>
</li>
<li><p>分配</p>
<ul>
<li><p>首次适应算法</p>
<ul>
<li>空闲分区以地址递增的次序排列</li>
<li>每次从低地址开始顺序查找，找到第一个能满足的空闲分区</li>
<li>最好，开销小。集中于低地址，高地址留下大空区概率大</li>
</ul>
</li>
<li><p>最佳适应算法</p>
<ul>
<li>空闲分区按容量递增的次序排列</li>
<li>顺序查找，优先使用能符合且最小的，留下大空闲区，分配后重新调整顺序</li>
<li>每次选最小会留下很多小外部碎片（最容易、最多），开销大</li>
</ul>
</li>
<li><p>最大适应算法最坏适应算法</p>
<ul>
<li>空闲分区按容量递减排序</li>
<li>顺序查找，先使用大分区，重新排序</li>
<li>大空区被用完，大程序运行不了，性能很差</li>
</ul>
</li>
<li><p>邻近适应算法</p>
<ul>
<li>空闲分区按地址递增排序，或使用循环链表</li>
<li>每次从上次查找结束的位置开始检索</li>
<li>减小首次适应的查找开销，高低地址使用概率相同，因此末尾也会被分成小块，性能不及首次适应算法。开销小。</li>
</ul>
</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li><p>无内部碎片</p>
</li>
<li><p>有外部碎片</p>
<ul>
<li>采用动态运行时装入技术</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>非连续分配管理方式</p>
<ul>
<li><p>分页管理</p>
<ul>
<li><p>将进程和内存空间分为大小相等的页和页框，OS以页框为单元分配内存，各个页不必连续存放</p>
</li>
<li><p>每个进程的PCB中都有一张页表页表通常装在连续的内存块中    每个页面对应一条页表项</p>
<ul>
<li><p><strong>页表：(页号)|块号（页框号）</strong></p>
<ul>
<li>页表大小&#x3D;块号大小×（内存块数+1）(B)页号不占字节（隐含）</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑地址：页号|页内偏移量</p>
<ul>
<li>页号&#x3D;逻辑地址&#x2F;页面大小(2^k B, 前k位)；页号&gt;页表长度则产生越界中断</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过页号查表找到块号，起始地址&#x3D;页面大小×块号；页内偏移量&#x3D;逻辑地址%页面大小(后k位)                    物理地址&#x3D;页面起始地址+页内偏移量</p>
<pre><code>                - 需要两次访存（查页表一次，访问物理地址一次）

        - 具有快表的地址变换机构

            - 先查快表再查慢表

                - 根据逻辑地址计算页号和页内偏移量，将页号与快表中的页号比较
                - 找到匹配页号，直接找到内存块

                    - 一次访存

                - 未命中，找到页表，将页表项放入快表，再找内存块

                    - 两次访存

            - 同时查

                - 快表查找成功则停止查找慢表

            - 增加TLB容量or让页表常驻内存能加快虚实地址转换 TLB用于地址变换

        - 两级页表

            - 单级页表问题

                - 页表项需要连续存放，占用大量空间

                    - 局部性原理，不用将进程全部放入

            - 解决

                - 将页表分组，每个内存块放一组页表项，离散在内存中

                    - 页表项增加一个标志位“是否在内存中”。不在→缺页中断→调入内存

            - 再建一张页表

                - 页目录表：外层页表、顶层页表

                    - 找到二级页表存放位置

                - 地址结构：一级页号|二级页号|页内偏移量
                - 各级页表大小不能超过一个页面

                    - 有28位页号，页面大小4KB，页表项大小4B→ 每个页面可放10个页表项，则28位分为8,10,10三级

                - 两(n)级页表需要三(n+1)次访存

                    - 1、页目录表；2、二级页表；3、内存单元

    - 段式管理

        - 按程序自身逻辑关系划分为若干个段，每段大小不等，有自己的段名，占连续空间，各段可不相邻
        - 逻辑地址：段号|段内地址

            - 位数：log2每个进程最多分几段|log2每段最大长度

        - **段表：(段号)|段长|段基址**

            - 段表项的长度相同；段号隐含，不占空间

        - 地址重定位

            - 根据逻辑地址得到段号和段内地址
            - 判断段号是否≥段表长度，越界中断
            - 查询段表，找到段表项。K号段地址=段表始址+k×段表项长度
            - 检查段内地址是否≥段长，越界中断
            - 物理地址=段基址+段内地址
            - 访问内存地址

        - **                                                                         对比**

            - 页

                - 物理单位

                    - 对用户不可见

                        - 大小固定，由系统决定

                            - 一维地址空间(地址)

                                - 两次访存

                - 优点：内存利用率高，无外部碎片，少量内部碎片；缺点：不方便信息共享和保护

            - 段

                - 逻辑单位

                    - 对用户可见

                        - 大小不固定

                            - 二维地址空间(段名+地址)

                                - 两次访存

                - 优点：更容易实现信息的共享(各进程段表项指向同一个段)和保护（+是否允许其他进程访问的标志位）；动态链接和动态增长，方便编程
                - 缺点：段长过大很难分配连续空间，会产生外部碎片

    - 段页式管理

        - 先分段再分页
        - 逻辑地址：段号|页号|页内偏移量
        - **段表：(段号)|段表长度|页表存放块号（始址）**

            - **页表：（页号）|内存块号**

        - 地址转换

            - 根据逻辑地址找到段号、页号、页内偏移量
            - 段号≥段表长，越界中断
            - 查段表找到页表

                - 一次访存

            - 页号≥页表长，越界中断
            - 查页表，得内存块号

                - 两次访存

            - 物理地址=内存块号+页内偏移量

                - 三次访存

- 内部碎片和外部碎片

    - 内部碎片

        - 分配给某进程的内存区域中有部分没用上

    - 外部碎片

        - =内存碎片，内存空间中的空闲分区太小而难以利用

            - 通过紧凑(拼凑)技术解决，需要动态重定位寄存器，费时
</code></pre>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><ul>
<li><p>传统存储管理(包括连续性和非连续性)</p>
<ul>
<li><p>一次性</p>
<ul>
<li><p>作业必须一次性全部装入内存后才能运行</p>
<ul>
<li>大作业无法运行</li>
<li>多道程序并发度下降(内存放不下)</li>
</ul>
</li>
</ul>
</li>
<li><p>驻留性</p>
<ul>
<li><p>作业运行结束前会一直驻留在内存中</p>
<ul>
<li>浪费内存，只要一部分程序就能运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟内存</p>
<ul>
<li><p>采用局部性原理，将很快会用到的调入内存</p>
<ul>
<li><p>多次性</p>
<ul>
<li>作业分多次调入内存</li>
</ul>
</li>
<li><p>对换性</p>
<ul>
<li>无需常驻，会换入换出</li>
</ul>
</li>
<li><p>虚拟性</p>
<ul>
<li>物理内存未变，逻辑上扩充</li>
</ul>
</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li><p>要访问信息不在内存时调入</p>
<ul>
<li>请求调页（段）功能</li>
</ul>
</li>
<li><p>内存不够时将用不到的调出</p>
<ul>
<li>页面（段）置换功能</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚存大小</p>
<ul>
<li><p>≤内存+外存容量之和</p>
<ul>
<li><p>≤计算机地址位数所能容纳最大范围</p>
<ul>
<li>由计算机地址位数（地址总线宽度）决定，与容量无关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="请求页式管理"><a href="#请求页式管理" class="headerlink" title="请求页式管理"></a>请求页式管理</h3><ul>
<li><p><strong>请求页表</strong></p>
<ul>
<li><strong>(页号)|内存块号|状态位(是1否0已调入内存)|访问字段(置换算法用)|修改位(是1否0被修改)|外存地址(页面在外存位置）</strong></li>
</ul>
</li>
<li><p>缺页中断机构</p>
<ul>
<li><p>要访问的页面不在内存中(页表中没有)，产生缺页中断(内中断)，由OS缺页中断处理程序处理</p>
<ul>
<li>请求调页</li>
</ul>
</li>
<li><p>缺页的进程阻塞，放入阻塞队列</p>
</li>
<li><p>没有空闲块（看进程驻留集大小），由页面置换算法选择淘汰页面，若已被修改则写回外存，若未被修改则不用写。新页面的页框号为被淘汰页框号(物理块号)</p>
<ul>
<li><p>页面置换</p>
<ul>
<li>快表中的页面一定在内存，若被换出也要删除快表项，调页后也要加入快表</li>
</ul>
</li>
</ul>
</li>
<li><p>内存中有空闲块，将所缺页面放入空闲块，修改相应页表项；</p>
<ul>
<li>修改请求页表项</li>
</ul>
</li>
<li><p>调页完成后将其唤醒，放入就绪队列</p>
</li>
<li><p>进程继续执行被中断的那一条指令</p>
</li>
</ul>
</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul>
<li><p>最佳置换算法</p>
<ul>
<li><p>每次选择以后永不使用或最长时间不再被使用的页面淘汰，保证最低缺页率</p>
<ul>
<li>缺页率&#x3D;缺页中断次数 &#x2F; 访问次数缺页次数≥页面置换次数</li>
</ul>
</li>
<li><p>操作系统无法预判访问序列，OPT无法实现</p>
</li>
</ul>
</li>
<li><p>先进先出置换算法</p>
<ul>
<li>淘汰最先进入内存的页面</li>
<li>把调入的页面按先后顺序排成队列，每次淘汰队首页面，队列最大长度取决于进程被分配多少内存块</li>
<li>会产生Belady异常(只有FIFO会)：为进程分配的物理块增多，缺页次数不减反增(也有减的时候)</li>
<li>实现简单，性能差</li>
</ul>
</li>
<li><p>最近最久未使用置换算法</p>
<ul>
<li>页表项中的访问字段记录页面上次被访问以来所经历的时间t，淘汰t最大的页面</li>
<li>手动做题时，逆向检查，最后（早）出现的页面被淘汰</li>
<li>最接近OPT，性能好；但实现需专门硬件(对所有页排序)，开销大</li>
</ul>
</li>
<li><p>时钟置换算法最近未用算法</p>
<ul>
<li><p>简单的CLOCK算法</p>
<ul>
<li><p>访问字段为访问位(0最近没访问&#x2F;1最近访问过)，所有页面链接成循环队列(像时钟)。</p>
</li>
<li><p>初始时将访问位全置0，被访问时置1</p>
</li>
<li><p>淘汰</p>
<ul>
<li><p>0，换出</p>
</li>
<li><p>1，置0，暂不换出</p>
<ul>
<li><p>所有页均为1</p>
<ul>
<li>进行第二轮扫描</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最多进行两轮扫描，未考虑是否被修改</p>
</li>
</ul>
</li>
<li><p>改进的CLOCK算法</p>
<ul>
<li><p>优先淘汰没有修改过的页面，每个页面(访问位，修改位)，形成循环队列</p>
</li>
<li><p>淘汰</p>
<ul>
<li><p>一轮</p>
<ul>
<li><p>从当前位置淘汰扫描到的第一个(0,0)，不修改任何标志位，失败进入二轮</p>
<ul>
<li>没访问没修改</li>
</ul>
</li>
</ul>
</li>
<li><p>二轮</p>
<ul>
<li><p>淘汰第一个(0,1)，将所有扫描过的页访问位置0，失败进入三轮(此时只有(0,0)和(0,1))</p>
<ul>
<li>没访问修改过</li>
</ul>
</li>
</ul>
</li>
<li><p>三轮</p>
<ul>
<li><p>淘汰第一个(0,0)，失败进入四轮</p>
<ul>
<li>访问过没修改</li>
</ul>
</li>
</ul>
</li>
<li><p>四轮</p>
<ul>
<li><p>淘汰第一个(0,1)</p>
<ul>
<li>访问过修改过</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最多进行四轮。好。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="页框分配策略"><a href="#页框分配策略" class="headerlink" title="页框分配策略"></a>页框分配策略</h3><ul>
<li><p>驻留集</p>
<ul>
<li><p>请求分页管理中给进程分配的物理块的集合</p>
</li>
<li><p>大小＜进程总大小，≥工作集，太小会频繁缺页，太大会导致并发度下降、资源利用率低</p>
</li>
<li><p>工作集</p>
<ul>
<li><p>某段时间间隔里，进程实际访问页面的集合。</p>
<ul>
<li>不同于驻留集</li>
</ul>
</li>
<li><p>根据窗口尺寸计算</p>
<ul>
<li>窗口尺寸为4，里面的页面有2343，则工作集大小为3</li>
<li>若工作集一直小于窗口尺寸，局部性很好，驻留集≥工作集可满足进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分配策略</p>
<ul>
<li><p>固定分配</p>
<ul>
<li>驻留集大小不变</li>
</ul>
</li>
<li><p>可变分配</p>
<ul>
<li>驻留集大小可变</li>
</ul>
</li>
</ul>
</li>
<li><p>置换策略</p>
<ul>
<li><p>局部置换</p>
<ul>
<li>缺页时选进程自己的物理块置换</li>
</ul>
</li>
<li><p>全局置换</p>
<ul>
<li>可置换OS保留的空闲块或其他进程物理块</li>
</ul>
</li>
</ul>
</li>
<li><p>最终策略</p>
<ul>
<li><p>固定分配局部置换</p>
<ul>
<li>很难在刚开始时确定要给进程分配多少物理块合理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> （根据进程大小、优先级、程序员给出的参数）</p>
<pre><code>- 可变分配全局置换

    - 开始为每个进程分配定量物理块，OS保持空闲物理块队列
    - 缺页则分配空闲物理块，若无空闲则分配未锁定页面（锁定的页面若内核数据，不能被换）
    - 缺页定会获得新的物理块，被选中进程物理块减少，缺页率增加

- 可变分配局部置换

    - 缺页只能换自己的，根据缺页频率动态调整驻留集大小
    - 若频繁缺页则OS会为其多分配物理块，至其缺页率适当；若缺页率特别低则减少其物理块。
</code></pre>
<ul>
<li><p>调入页面的时机</p>
<ul>
<li><p>预调页策略</p>
<ul>
<li>根据空间局部性原理，一次调入若干相邻页面(预测成功率低)，主要用于进程运行前的首次调入，由程序指明先调入部分</li>
</ul>
</li>
<li><p>请求调页策略</p>
<ul>
<li>运行时，缺页时调入，调入的一定会被访问，但每次只能调入一页，需要进行I&#x2F;O，开销大</li>
</ul>
</li>
</ul>
</li>
<li><p>从何处调入页面</p>
<ul>
<li><p>有足够对换区</p>
<ul>
<li><p>调入调出都在内存与对换区之间</p>
<ul>
<li>外存分为对换区(读写快，连续分配)和文件区(读写慢，离散分配)，运行前将相关数据从文件区复制到对换区</li>
</ul>
</li>
</ul>
</li>
<li><p>缺少足够对换区</p>
<ul>
<li>不会被修改的从文件区调入</li>
<li>可能被修改的换出时写回对换区，下次再从对换区调入</li>
</ul>
</li>
<li><p>UNIX方式</p>
<ul>
<li>未使用过的从文件区调入，运行过又被换出的存放在对换区，下次再从对换区调入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ul>
<li><p>将磁盘文件的全部或部分内容，与进程虚拟地址空间的某个区域，建立映射关系，便可以直接访问被映射的文件</p>
<ul>
<li>不必执行文件I&#x2F;O操作，也无需对文件内容进行缓存处理，十分适合用来管理大尺寸文件</li>
</ul>
</li>
<li><p>使用内存映射文件的所有实际交互都只在内存中进行的，并以标准的内存地址形式来访问</p>
<ul>
<li>磁盘周期性分页是OS在后台隐蔽实现的，对应用程序完全透明</li>
</ul>
</li>
<li><p>系统内存中的所有页面由虚拟存储器负责管理，以统一的方式处理所有磁盘I&#x2F;O。当进程退出或显示地解除文件映射时，所有被改动的页面会被写回到磁盘文件</p>
</li>
<li><p>多个进程允许并发地内存映射同一文件，以允许和实现数据共享</p>
<ul>
<li>共享内存是通过映射相同文件到通信进程的虚拟地址空间实现的。内存映射文件可以充当通信进程间的共享内存区域。</li>
</ul>
</li>
<li></li>
<li><p>内存映射接口提供通过内存的字节数组来访问磁盘，而不提供读和写操作。</p>
<ul>
<li>映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只有需要访问内存映像时，才会由虚拟存储器实际调页。</li>
</ul>
</li>
<li><p>内存映射文件的访问如同内存读写一样简单，极大的方便了程序员。</p>
</li>
</ul>
<h3 id="虚拟存储器性能的影响因素及改进方法"><a href="#虚拟存储器性能的影响因素及改进方法" class="headerlink" title="虚拟存储器性能的影响因素及改进方法"></a>虚拟存储器性能的影响因素及改进方法</h3><ul>
<li><p>缺页率</p>
<ul>
<li><p>是影响虚拟存储器性能的主要因素</p>
</li>
<li><p>受影响</p>
<ul>
<li><p>页面大小</p>
<ul>
<li>根据局部性原理，页面大则缺页率低，页面小则缺页率高</li>
<li>页面小时，减少内存碎片，提高内存利用率；使每个进程要求较多页面，导致页表过长，占用大量内存</li>
<li>页面大时，减少页表长度；增大页内碎片</li>
</ul>
</li>
<li><p>分配给进程的物理页面数</p>
<ul>
<li>越接近进程逻辑页面数量，缺页率就会越低</li>
<li>分配过多会浪费内存空间，只要保证活跃页面在内存，保持缺页率在一个很低范围即可</li>
</ul>
</li>
<li><p>页面置换算法</p>
<ul>
<li>LRU、CLOCK等，将未来可能访问的页面尽可能保留在内存中</li>
</ul>
</li>
<li><p>编制方法</p>
<ul>
<li>编程的局部化程度越高，缺页率越低</li>
<li>存储采用按行存储时，尽量采用相同的访问方式，避免按列访问造成缺页率过高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>抖动(颠簸)现象</p>
<ul>
<li><p>刚换出马上又换入</p>
<ul>
<li>主要原因：分配给进程的物理块不够</li>
</ul>
</li>
</ul>
</li>
<li><p>工作集大小</p>
</li>
</ul>

  </div>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2022
  BONE
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/FloatinDLE"><i class="blogfont">&#xe6b7; </i></a>
  
    <a class="social-links" href="mailto:bone_n@foxmail.com"><i class="blogfont">&#xe61a; </i></a>
  
    <a class="social-links" href="/atom.xml"><i class="blogfont">&#xe640; </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>