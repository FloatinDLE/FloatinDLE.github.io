<!DOCTYPE html>
<html  lang=en>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
    
    <link rel="shortcut icon" href="/images/kou.ico ">
    
    
    <link rel="icon" type="image/png" href="/images/favicon-android.png " sizes="192x192">
    
    
    <link rel="apple-touch-icon" href="/images/favicon-apple.png " sizes="180x180">
    
  
  <!-- title -->
  <title>地下室 操作系统基础 </title>
  <!-- styles -->
  <!-- styles -->

<link rel="stylesheet" href="/styles/global.css">

  <!-- rss -->
  
<meta name="generator" content="Hexo 5.4.1"></head>
  <body>
    <header id="header">
  
  <nav class="menu menu--right">
  
    <a class="menu__item" href="/">主页</a>
    <a class="menu__item" href="/archives/">归档</a>
    <a class="menu__item" href="/categories/">专题</a>
    <a class="menu__item" href="/tags/">标签</a>
    <!-- <a class="menu__item" href="/">作品</a> -->
    <!-- <a class="menu__item" href="/about/">关于</a> -->
  </nav>
</header>
    <main>
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
  <h1 class="post__title">操作系统基础</h1>
  
  
  <div class="post__meta">
    
<time class="post__date" datetime="2022-04-10T01:43:25.000Z" itemprop="datePublished">
  
  <i class="blogfont">&#xedff;</i>
  
  2022-04-10 09:43:25
</time>

    
<div class="post__category">
  <i class="blogfont">&#xe62d;</i>
  <a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
</div>
  

    
<div class="post__tag">
  <i class="blogfont">&#xe7ec;</i>
  <a class="tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a>
</div>


    <div id="/2022/04/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" class="leancloud_visitors post__stat" data-flag-title="操作系统基础">
  <i class="blogfont">&#xe672;</i>
  <span class="leancloud-visitors-count">loading...</span>
</div>
  </div>
</header>
  <aside class="post__aside">
  <div class="post__actions">
    <a id="backTop" class="post__top" href="javascript:">
      <i class="blogfont">&#xe6b1;</i><!-- Top -->
    </a>
    <a id="share" class="post__share" href="javascript:">
      <i class="blogfont">&#xe6c1;</i>
    </a>
  </div>
  <ol class="post__toc"><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post__toc-text">操作系统的基本概念</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="post__toc-text">概念</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="post__toc-text">功能和目标</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E7%89%B9%E5%BE%81"><span class="post__toc-text">特征</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="post__toc-text">操作系统发展历程</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5"><span class="post__toc-text">手工操作阶段</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">单道批处理系统</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">多道批处理系统</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">分时操作系统</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">实时操作系统</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">网络操作系统</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">分布式操作系统</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">个人计算机操作系统</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="post__toc-text">程序运行环境</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#CPU%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="post__toc-text">CPU运行模式</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="post__toc-text">中断和异常的处理</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="post__toc-text">系统调用</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E5%85%A5"><span class="post__toc-text">程序的链接和装入</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="post__toc-text">程序运行时内存映像与地址空间</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="post__toc-text">操作系统结构</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%88%86%E5%B1%82%E6%B3%95"><span class="post__toc-text">分层法</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="post__toc-text">模块化</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84"><span class="post__toc-text">内核架构</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E5%A4%96%E6%A0%B8"><span class="post__toc-text">外核</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="post__toc-text">操作系统引导</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%A9%E7%94%A8CPU%E8%BF%90%E8%A1%8C%E7%89%B9%E5%AE%9A%E7%A8%8B%E5%BA%8F%EF%BC%8C%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E8%AF%86%E5%88%AB%E7%A1%AC%E7%9B%98%EF%BC%8C%E8%AF%86%E5%88%AB%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%EF%BC%8C%E8%AF%86%E5%88%AB%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%9C%80%E5%90%8E%E9%80%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="post__toc-text">计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="post__toc-text">过程</span></a></li></ol></li><li class="post__toc-item post__toc-level-2"><a class="post__toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="post__toc-text">虚拟机</span></a><ol class="post__toc-child"><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%A6%86%E7%9B%96%E4%BA%86%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%A3%B8%E6%9C%BA"><span class="post__toc-text">覆盖了软件的裸机</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E9%80%BB%E8%BE%91%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E5%88%A9%E7%94%A8%E7%89%B9%E6%AE%8A%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%8C%E9%80%9A%E8%BF%87%E9%9A%90%E8%97%8F%E7%89%B9%E5%AE%9A%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AE%9E%E9%99%85%E7%89%A9%E7%90%86%E7%89%B9%E6%80%A7%EF%BC%8C%E4%B8%BA%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E6%8A%BD%E8%B1%A1%E7%9A%84%E3%80%81%E7%BB%9F%E4%B8%80%E7%9A%84%E3%80%81%E6%A8%A1%E6%8B%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83"><span class="post__toc-text">逻辑的计算机，利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境</span></a></li><li class="post__toc-item post__toc-level-3"><a class="post__toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%96%B9%E6%B3%95"><span class="post__toc-text">虚拟化方法</span></a></li></ol></li></ol>
</aside>
  <div class="post__content" itemprop="articleBody">
    <h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>计算机层次</p>
<ul>
<li><p>用户</p>
</li>
<li><p>应用程序（软件）</p>
<ul>
<li>规定按何种方式使用计算资源来解决用户的计算问题</li>
</ul>
</li>
<li><p>操作系统</p>
<ul>
<li>控制和协调各用户的应用程序对硬件的分配和使用</li>
</ul>
</li>
<li><p>裸机（纯硬件）</p>
<ul>
<li>提供基本计算资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h3><ul>
<li><p>系统资源管理者</p>
<ul>
<li><p>处理机管理</p>
<ul>
<li><p>进程管理</p>
<ul>
<li>任务：进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享</li>
<li>功能：进程控制、进程同步、进程通信、死锁处理、处理机调度</li>
</ul>
</li>
</ul>
</li>
<li><p>存储器管理</p>
<ul>
<li><p>内存分配与回收、地址映射、内存保护与共享、内存扩充</p>
<ul>
<li>缓存全部由操作系统管理，不提供接口</li>
</ul>
</li>
</ul>
</li>
<li><p>文件管理</p>
<ul>
<li>文件存储空间的管理、目录管理、文件读写管理和保护</li>
</ul>
</li>
<li><p>设备管理</p>
<ul>
<li>完成用户的I&#x2F;O请求。缓存管理、设备分配、设备处理、虚拟设备</li>
</ul>
</li>
</ul>
</li>
<li><p>向上提供方便易用的服务（封装）</p>
<ul>
<li><p>命令接口和程序接口<br>（系统调用）</p>
<ul>
<li><p>GUI图形化用户接口</p>
<ul>
<li>调用系统调用</li>
</ul>
</li>
<li><p>联机命令接口（交互式命令接口）</p>
<ul>
<li>CMD、shell（命令解析器）用户说一句，系统做一句</li>
</ul>
</li>
<li><p>脱机命令接口（批处理命令接口）</p>
<ul>
<li>使用.bat文件说一堆做一堆</li>
</ul>
</li>
<li><p>程序接口</p>
<ul>
<li>在程序中进行系统调用（广义指令&#x3D;系统调用命令），请求系统服务，如printf</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最基本的软件</p>
<ul>
<li>扩充机器</li>
</ul>
</li>
</ul>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li><p>并发</p>
<ul>
<li><p>多个事件在统一时间间隔发生，宏观同时，微观交替</p>
<ul>
<li>并行：在同一时刻发生                      单核CPU只能并发（各任务分别占用一段时间，切换），多核可以并行</li>
</ul>
</li>
</ul>
</li>
<li><p>共享</p>
<ul>
<li><p>系统资源可供多个并发进程同时使用</p>
<ul>
<li><p>互斥共享方式</p>
<ul>
<li>一个时间段只允许一个——摄像头</li>
</ul>
</li>
<li><p>同时访问方式</p>
<ul>
<li>允许多个“同时”——硬盘资源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟</p>
<ul>
<li><p>把一个物理实体变若干个逻辑上的对应物</p>
<ul>
<li><p>空分复用技术</p>
<ul>
<li>虚拟存储器</li>
</ul>
</li>
<li><p>时分复用技术</p>
<ul>
<li>虚拟处理器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li>资源有限不够分配时，会走走停停，以不可预知的速度前进</li>
</ul>
</li>
<li><p>多道程序设计的基本特征</p>
<ul>
<li>制约性、间断性、共享性</li>
</ul>
</li>
<li><p>单道程序设计的基本特征</p>
<ul>
<li>顺序性</li>
</ul>
</li>
</ul>
<h2 id="操作系统发展历程"><a href="#操作系统发展历程" class="headerlink" title="操作系统发展历程"></a>操作系统发展历程</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><ul>
<li><p>无OS</p>
<ul>
<li>资源（CPU）利用率低</li>
</ul>
</li>
</ul>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><ul>
<li><p>引入脱机输入输出技术，监督程序</p>
<ul>
<li>有所提升，同一时刻只有一道程序，利用率低</li>
</ul>
</li>
</ul>
<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul>
<li><p><strong>操作系统正式诞生</strong></p>
<ul>
<li><p>每次往内存读入多道程序，提高CPU和I&#x2F;O设备利用率、总吞吐量，系统开销大；借助中断技术可以让I&#x2F;O设备与CPU并行工作</p>
<ul>
<li>可并发、共享，大幅提升；没有人机交互</li>
</ul>
</li>
<li><p>多道进程度数</p>
<ul>
<li>主存中的用户进程数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><ul>
<li><p>非抢占式优先级</p>
<ul>
<li><p>以时间片为单位轮流为各个用户&#x2F;作业服务</p>
<ul>
<li>解决人机交互，允许多个用户同时使用；没有优先级</li>
<li>UNIX</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><ul>
<li><p>进程调度采用抢占式优先级</p>
<ul>
<li><p>接收到外部信号后及时处理，优先响应紧急任务，必须在被控对象规定时间内处理外部事件</p>
<ul>
<li>及时性、可靠性；交互性不如分时</li>
</ul>
</li>
<li><p>硬实时</p>
<ul>
<li><p>绝对严格</p>
<ul>
<li>导弹、自动驾驶</li>
</ul>
</li>
</ul>
</li>
<li><p>软实时</p>
<ul>
<li>12306订票</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h3><ul>
<li><p>网络中各种资源的共享和计算间通信</p>
<ul>
<li>服务于计算机网络 ，集中式控制方式</li>
</ul>
</li>
</ul>
<h3 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h3><ul>
<li><p>若干计算机相互协同完成同一任务</p>
<ul>
<li>分布性和并行性</li>
</ul>
</li>
</ul>
<h3 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h3><ul>
<li>目前最广泛，Windows、Linux</li>
</ul>
<h2 id="程序运行环境"><a href="#程序运行环境" class="headerlink" title="程序运行环境"></a>程序运行环境</h2><h3 id="CPU运行模式"><a href="#CPU运行模式" class="headerlink" title="CPU运行模式"></a>CPU运行模式</h3><ul>
<li><p>内核模式</p>
<ul>
<li><p>内核态、核心态、管态</p>
<ul>
<li>正在运行内核程序，</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以执行除访管外所有指令</p>
<pre><code>        - 内核程序

            - 实现操作系统，组成内核，OS最核心最接近硬件的部分，一个操作系统只要有内核就够了
</code></pre>
<ul>
<li><p>用户模式</p>
<ul>
<li><p>用户态、目态</p>
<ul>
<li><p>正在运行应用程序，只能执行非特权指令</p>
<ul>
<li><p>应用程序</p>
<ul>
<li>写在OS上，只能使用非特权指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>状态切换</p>
<ul>
<li><p>PSW中 1：内核态；0：用户态</p>
<ul>
<li>用户态→内核态由硬件（触发中断）完成，中断返回程序时内核态→用户态</li>
</ul>
</li>
<li><p>为了保护系统程序</p>
</li>
<li><p>开机时为内核态，OS内核程序上CPU</p>
</li>
<li><p>开机完成后，用户启动应用程序，用特权指令将PSW置0，内核程序让出CPU，应用程序上CPU</p>
</li>
<li><p>命令解释程序在用户态执行；系统调用发生在用户态；进程切换发生在核心态</p>
</li>
<li><p>若黑客植入特权指令，CPU处于用户态；会引发中断信号，CPU变为核心态，停止运行当前程序，转而处理中断信号</p>
</li>
<li><p>中断使OS夺回CPU控制权</p>
</li>
<li><p>中断处理完成后CPU使用权再次被交给别的应用</p>
<ul>
<li>关中断和开中断属于特权指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="中断和异常的处理"><a href="#中断和异常的处理" class="headerlink" title="中断和异常的处理"></a>中断和异常的处理</h3><ul>
<li><p>中断</p>
<ul>
<li><p>让OS内核夺回CPU使用权的唯一途径</p>
<ul>
<li><p>内中断（异常、例外）</p>
<ul>
<li><p>与当前执行指令有关，源于CPU内部</p>
<ul>
<li>被除数为0（不可修复，abort终止指令），trap指令</li>
</ul>
</li>
</ul>
</li>
<li><p>外中断（中断）</p>
<ul>
<li><p>源于CPU外部</p>
<ul>
<li>时钟中断（处理系统时间、进程时间片、延时、使用CPU的时间、定时器有关信息，决定是否执行调度程序），I&#x2F;O中断</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li><p>对同时发出使用同一设备（共享资源） 的请求进行协调处理</p>
</li>
<li><p>按功能分类</p>
<ul>
<li><p>设备管理</p>
</li>
<li><p>文件管理</p>
</li>
<li><p>进程控制</p>
<ul>
<li>单一进程</li>
</ul>
</li>
<li><p>进程通信</p>
<ul>
<li>进程之间</li>
</ul>
</li>
<li><p>内存管理</p>
</li>
</ul>
</li>
<li><p>过程</p>
<ul>
<li>程序给CPU传参数，执行trap指令，CPU中断进入系统调用入口程序，根据参数找到具体程序</li>
</ul>
</li>
</ul>
<h3 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h3><ul>
<li>见内存管理</li>
</ul>
<h3 id="程序运行时内存映像与地址空间"><a href="#程序运行时内存映像与地址空间" class="headerlink" title="程序运行时内存映像与地址空间"></a>程序运行时内存映像与地址空间</h3><ul>
<li><p>内存映像</p>
<ul>
<li><p>一个程序调入内存运行时就构成了进程的内存映像</p>
</li>
<li><p>要素</p>
<ul>
<li><p>代码段</p>
<ul>
<li>二进制代码，只读的，可以被多个进程共享</li>
</ul>
</li>
<li><p>数据段</p>
<ul>
<li>程序运行时加工处理对象，包括全局变量和静态变量</li>
</ul>
</li>
<li><p>PCB</p>
<ul>
<li>存放在系统区，OS通过PCB来控制和管理进程</li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li>用来存放动态分配的变量</li>
</ul>
</li>
<li><p>栈</p>
<ul>
<li>用来实现函数调用</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>共享库函数代码：printf()等</li>
<li>.data是已初始化的全局变量和静态变量；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> .bss是未初始化及所有初始化为0的全局变量和静态变量<br>        - .init：程序初始化时调用的_init函数；<br> .text是用户程序的机器代码；.rodata是只读数据</p>
<ul>
<li><p>地址空间</p>
<ul>
<li><p>在进程创建的过程中，程序内容被映射到进程的虚拟内存空间，为了让一个很大的程序在有限的物理内存空间运行，我们可以把这个程序的开始部分先加载到物理内存空间运行，因为操作系统处理的是进程的虚拟地址，如果在进行虚拟到物理地址的转换工程中，发现物理地址不存在时，这个时候就会发生缺页异常(nopage)</p>
</li>
<li><p>每个进程都有一个独立的地址空间，这个地址空间的地址为虚拟地址</p>
<ul>
<li>对32位进程来说，由于32位指针可以表示从0x00000000到0xFFFFFFFF之间的任一值，地址空间的大小为4GB</li>
</ul>
</li>
<li><p>OS通过内存管理部件MMU(硬件)，将进程使用的虚拟地址转换为物理地址，虚拟地址通过页表映射到物理内存</p>
</li>
</ul>
</li>
</ul>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h3 id="分层法"><a href="#分层法" class="headerlink" title="分层法"></a>分层法</h3><p>- </p>
<pre><code>- 将OS分为若干层次，最底层(层0)为硬件，最高层(层N)为用户接口，每层只能调用它的低一层的功能和服务（单向依赖）
</code></pre>
<ul>
<li><p>优点</p>
<ul>
<li><p>便于系统的调试和验证，简化了系统的设计和实现</p>
<ul>
<li>如果在调试某层时发现错误，错误就在这层上，因为所有低层都已调试好</li>
</ul>
</li>
<li><p>易扩充和易维护</p>
<ul>
<li>对某一层次进行增加、修改或替换时，只要不改变相应层次间的接口，就不会影响其他层次</li>
</ul>
</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li><p>合理定义各层比较困难</p>
<ul>
<li>不够灵活</li>
</ul>
</li>
<li><p>效率较差</p>
<ul>
<li>每执行一个功能，就要穿越多个层，层间通信增加额外开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>- </p>
<pre><code>- 将OS按功能划分为若干具有一定独立性的模块
- 每个模块具有某方面的管理功能，并规定好各模块接口，使相互能进行通信
- 可以将各模块细分为子模块，定义好子模块之间的接口。模块—接口法
</code></pre>
<ul>
<li><p>模块划分太小，会引起模块之间联系过多，系统混乱；如果模块划分太大，会增加模块内部的复杂性</p>
</li>
<li><p>模块独立性越高，交互越少，系统结构越清晰，标准：</p>
<ul>
<li><p>内聚性</p>
<ul>
<li><p>模块内部各部分间联系的紧密度</p>
<ul>
<li>越高，独立性越好</li>
</ul>
</li>
</ul>
</li>
<li><p>耦合度</p>
<ul>
<li><p>模块间相互联系和相互影响的程度</p>
<ul>
<li>越低，独立性越好</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>提高了OS设计的正确性、可理解性和可维护性</li>
<li>增强了OS的可适应性</li>
<li>加速了OS的开发过程</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>模块间的接口很难满足对接口的实际需求</li>
<li>各模块设计者齐头并进，无法寻找到一个可靠的决定顺序</li>
</ul>
</li>
</ul>
<h3 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h3><ul>
<li><p>非内核功能（GUI）</p>
<ul>
<li>Ubuntu</li>
</ul>
</li>
<li><p>进程管理、存储器管理、设备管理等系统调用</p>
</li>
<li><p>时钟管理、中断管理、原语</p>
<ul>
<li><p>微内核</p>
<ul>
<li>WindowsNT，实时、工业、航空、军事，高度可靠性</li>
<li>包含：与硬件紧密部分、较基本功能、客户和服务器之间的通信——绝大部分功能都在内核外的一组服务器(进程)中实现</li>
<li>中断需多次变态</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> （进程管理等都要变态）<br>        - 功能少；结构清晰，方便维护，模块崩溃不会导致内核崩溃，内核更稳定，系统更可靠；添加系统服务时不必修改内核，扩展性和灵活性好；分布式计算；可移植性</p>
<h3 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h3><ul>
<li><p>一种在内核态中运行的程序，任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。</p>
</li>
<li><p>优点</p>
<ul>
<li><p>减少了映射层</p>
<ul>
<li>对机器进行分区，给每个用户整个资源的一个子集，某虚拟机得到磁盘的0<del>1023盘块，另一台等到1024</del>2047</li>
<li>外核只需记录已经分配给各个虚拟机的有关资源即可</li>
</ul>
</li>
<li><p>将多道程序(在外核内)，与用户操作系统代码(在用户空间内)加以分离</p>
</li>
</ul>
</li>
</ul>
<h2 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h2><h3 id="计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统"><a href="#计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统" class="headerlink" title="计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统"></a>计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统</h3><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li><p>1.激活CPU</p>
<ul>
<li>激活的CPU读取ROM(主存，CPU外)里的boot程序，将指令寄存器置为BIOS的第一条指令，即开始执行BIOS指令（基本输入输出系统，存放在CMOS中，CMOS是保存计算机基本启动信息的芯片）</li>
</ul>
</li>
<li><p>2.硬件自检</p>
<ul>
<li>启动BIOS后，先检查硬件是否出现故障，如有故障，主板会发出不同含义的蜂鸣，启动中止；如无故障，屏幕会显示CPU、内存、硬盘信息</li>
</ul>
</li>
<li><p>3.加载带有操作系统的硬盘</p>
<ul>
<li>BIOS开始读取Boot Sequence（CMOS中设置的启动顺序），把控制权交给排第一的存储设备，CPU将该设备引导的扇区内容加载到内存中。硬盘以特定标识符区分引导硬盘和非引导硬盘，CPU通过遍历找带有主引导记录的硬盘，主引导记录告诉CPU去该硬盘哪个主分区找操作系统</li>
</ul>
</li>
<li><p>4.加载主引导记录MBR</p>
<ul>
<li>MBR中包含硬盘分区表</li>
</ul>
</li>
<li><p>5.加载硬盘分区表</p>
<ul>
<li>扫描盘分区表，识别含有操作系统的硬盘分区(活动分区)，活动分区和非活动分区由特定标识符区分</li>
</ul>
</li>
<li><p>6.加载磁盘活动分区</p>
<ul>
<li>每个分区可以安装不同的操作系统，主引导记录必须知道将控制权交给哪个分区</li>
</ul>
</li>
<li><p>7.加载分区引导记录PBR</p>
<ul>
<li>读取活动分区的第一个扇区，该扇区就是PBR，作用是寻找并激活分区根目录下，用于引导操作系统的程序(启动管理器)</li>
</ul>
</li>
<li><p>8.加载启动管理器</p>
</li>
<li><p>9.加载操作系统</p>
</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="覆盖了软件的裸机"><a href="#覆盖了软件的裸机" class="headerlink" title="覆盖了软件的裸机"></a>覆盖了软件的裸机</h3><h3 id="逻辑的计算机，利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境"><a href="#逻辑的计算机，利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境" class="headerlink" title="逻辑的计算机，利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境"></a>逻辑的计算机，利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境</h3><h3 id="虚拟化方法"><a href="#虚拟化方法" class="headerlink" title="虚拟化方法"></a>虚拟化方法</h3><ul>
<li><p>第一类虚拟机管理程序</p>
<ul>
<li><p>像一个操作系统，是唯一一个运行在最高特权级的程序</p>
</li>
<li></li>
<li><p>在裸机上运行并具备多道程序功能；向上提供了若干台虚拟机。这些虚拟机是裸机硬件的精确复制品，每台虚拟机都与裸机相同，不同虚拟机上可以运行任何不同的操作系统</p>
</li>
<li><p>虚拟机作为用户态的一个进程运行，然而虚拟机上的操作系统认为自己运行在内核态，称为虚拟内核态。虚拟机中的用户进程认为自己运行在用户态（确实）</p>
<ul>
<li>虚拟机OS执行一条特权指令时，会陷入虚拟机管理程序，安排这条指令正确执行；用户程序执行时，会模拟真实硬件面对用户态的行为</li>
</ul>
</li>
</ul>
</li>
<li><p>第二类虚拟机管理程序</p>
<ul>
<li><p>像一个普通进程，是一个依赖于Windows等操作系统分配和调度资源的程序</p>
</li>
<li><ul>
<li>VMware Workstation</li>
</ul>
</li>
<li><p>仍伪装成具有CPU和各种设备的完整计算机，客户操作系统可以安装到虚拟磁盘上(宿主操作系统的一个文件)</p>
</li>
<li><p>一台物理服务器可以运行多个虚拟机，客户可以租用并在上面安装自己想用的OS和软件，“云主机”</p>
</li>
</ul>
</li>
</ul>

  </div>
  
</article>
    </main>
    <footer id="footer">
  Copyright &copy;
  2022
  BONE
  
  
    <a class="social-links" target="_blank" rel="noopener" href="https://github.com/FloatinDLE"><i class="blogfont">&#xe6b7; </i></a>
  
    <a class="social-links" href="mailto:bone_n@foxmail.com"><i class="blogfont">&#xe61a; </i></a>
  
    <a class="social-links" href="/atom.xml"><i class="blogfont">&#xe640; </i></a>
  
  
</footer>
    <!-- scripts -->

<script src="/scripts/main.js"></script>

  </body>
</html>